# Cycle 05 Specification: UI/UX, Finalisation, and Documentation

## 1. Summary

This document provides the technical specifications for Cycle 05, the final and concluding phase of the MLIP-AutoPipe project's initial development. The focus of this cycle shifts from the implementation of new core scientific capabilities to the critical aspects of **User Experience (UX)**, **Finalisation**, and **Documentation**. While the previous cycles successfully built a powerful and autonomous core engine for MLIP generation, this cycle is dedicated to ensuring that the system is not just functional but also usable, accessible, robust, and maintainable. The primary goal is to polish all the user-facing aspects of the tool, transforming it from a collection of powerful but disparate scripts into a professional, cohesive, and distributable software package that is ready for use by the wider materials science community.

The key deliverables for this cycle are centred around the user's interaction with the software. This begins with the development of a clean, intuitive, and self-documenting **Command-Line Interface (CLI)**, which will serve as the single, unified entry point for all user interactions. This CLI will abstract away the internal orchestration logic and provide a simple, command-based way to launch and manage the pipeline. Secondly, the cycle will focus on implementing a comprehensive and configurable **logging and progress monitoring** system. This is of paramount importance for a long-running scientific workflow, as it provides the user with essential transparency into the system's state, progress, and any issues that may arise, preventing the "black box" experience. Finally, this cycle will involve a thorough code cleanup, the systematic addition of developer-focused documentation (such as docstrings and full type hints) to ensure the project's long-term maintainability, and, most importantly, the creation of clear, comprehensive user-facing documentation, including tutorials and examples. Upon completion of this cycle, the MLIP-AutoPipe will be a mature, well-documented, and user-friendly tool, ready for its initial release and for future development to build upon its solid foundation.

## 2. System Architecture

The architecture for Cycle 05 does not introduce new scientific modules. Instead, it wraps the existing, powerful pipeline in a more robust and user-friendly presentation and interaction layer. This architecture is about building a solid "shell" around the core engine.

1.  **Command-Line Interface (CLI):** A new, single entry point for the entire application will be created, which will be available to the user as a command, for instance `mlip-pipe`. This will be built using a modern CLI library like `click` or `typer` to ensure a professional and easily extensible interface.
    *   **Main Command:** A primary `run` command (e.g., `mlip-pipe run`) will be the main way for a user to execute the pipeline.
    *   **Arguments/Options:** This command will take the path to the `input.yaml` file as its primary, required argument. It will also feature several options to control the behaviour of the run, such as `--verbose` to increase the logging output for debugging, `--output-dir` to specify a custom location for the results, and potentially a `--resume` flag to allow the continuation of a previous, interrupted run.
    *   **Sub-commands (Optional but Recommended):** To improve usability, additional sub-commands will be designed. For example, `mlip-pipe validate` could be implemented to quickly check the syntax and validity of an `input.yaml` file without starting a long calculation. Another command, `mlip-pipe results`, could be designed to parse the output of a completed run and print a concise summary of the key findings (e.g., final model accuracy, number of active learning cycles).
2.  **Logging System:** A centralised and configurable logging system will be implemented using Python's built-in `logging` module. This is a critical feature for a complex, long-running application.
    *   **Configuration:** The logger will be configured at the application's entry point (in the CLI). It will be set up to output messages to two destinations simultaneously: the console (for immediate user feedback) and a dedicated log file (`mlip-autopipec.log`) within the run's output directory (for a persistent, detailed record).
    *   **Verbosity Levels:** The CLI's `--verbose` flag will directly control the logging level. By default (without the flag), the user will see standard progress messages at the `INFO` level. If the flag is present, the logging level will be set to `DEBUG`, providing a much more detailed output that is invaluable for developers and for debugging complex issues.
    *   **Structured Logging:** All log messages generated by the different modules of the pipeline will be standardised to include a timestamp, the logging level, and the name of the module that originated the message (e.g., `2023-10-27 10:30:15 - INFO - [LabellingEngine] - Starting DFT calculation for structure 42.`). This structured approach makes the log files much easier to parse and understand.
3.  **Progress Monitoring:** For long-running processes, particularly the MD simulations in the `Explorer` and the main active learning loop in the `Orchestrator`, providing real-time feedback is essential to a good user experience. A library like `rich` or `tqdm` will be integrated to display clean and informative progress bars on the console. This will provide the user with a visual indicator of the progress of the current stage (e.g., percentage of MD steps completed) and the overall workflow (e.g., "Active Learning Generation 3 of 10"), along with an estimated time remaining.
4.  **Documentation:** A two-pronged documentation strategy will be implemented.
    *   **User Documentation:** A `docs` directory will be created within the project, containing user-facing documentation written in Markdown. This will be structured to be easily navigable and will include a "Getting Started" guide, a detailed explanation of every parameter in the `input.yaml` format, and several tutorials walking through complete examples for different material types (e.g., an alloy, a molecule).
    *   **Developer Documentation:** All public classes and functions throughout the codebase will be annotated with comprehensive docstrings, following a standard format like Google's or NumPy's. Full type hints will be added to all function signatures and variables. This internal documentation is crucial for the long-term health and maintainability of the project, making it easier for new developers to understand the codebase and contribute.

## 3. Design Architecture

The design for this cycle focuses on implementing the presentation layer and introducing codebase-wide refinements to improve quality and maintainability.

-   **`src/mlip_autopipec/main.py`:**
    -   This file will be refactored to contain all the CLI logic, using `typer` for its modern, type-hint-based approach.
    -   A `typer.Typer()` application object will be defined here.
    -   The main `run` command will be implemented as a function decorated with `@app.command()`. This function will be responsible for:
        1.  Calling the `setup_logging` utility function.
        2.  Reading the path to the `input.yaml` file from the command-line arguments.
        3.  Instantiating the main `Orchestrator` class and passing it the configuration.
        4.  Calling the `execute()` method on the orchestrator instance to run the pipeline.
        5.  Wrapping the execution in a `try...except` block to catch any exceptions and log them gracefully before exiting.
-   **`src/mlip_autopipec/orchestrator.py`:**
    -   The main workflow logic developed in the previous cycles will be encapsulated into a formal `Orchestrator` class if it has not been already.
    -   The `__init__` method of this class will be refactored to take a `logging.Logger` object and potentially a progress callback handler as arguments. This allows the CLI layer to inject the presentation layer components into the core logic, cleanly decoupling the two. The orchestrator itself will not know whether it's writing to a console or a file; it will simply use the provided logger object.
-   **`src/mlip_autopipec/logging_config.py`:**
    -   A new file will be created to house a dedicated function, `setup_logging(level: int, log_file: Path)`. This function will contain all the boilerplate code for configuring the root logger for the entire application, including setting up formatters and handlers for both the console and the log file.
-   **Codebase-wide Refinements:**
    -   A systematic pass will be made through all existing modules (`structure_generator.py`, `explorer.py`, `labelling_engine.py`, etc.).
    -   **Docstrings:** All public functions, classes, and methods will be documented with clear docstrings explaining their purpose, arguments, and return values.
    -   **Type Hinting:** All function signatures and variable declarations will be fully and correctly type-hinted. A static type checker, `mypy`, will be added to the project's development dependencies and configured to enforce strict type checking as part of the continuous integration process.
    -   **Linting:** A strict `ruff` configuration will be defined in `pyproject.toml` and applied across the entire project. This will enforce a consistent, high-quality code style and catch a wide range of potential bugs and anti-patterns.
-   **`docs/` directory:**
    -   A new top-level `docs` directory will be created.
    -   `getting_started.md`: A step-by-step guide on how to install the software, set up the necessary environment variables (like API keys if needed), and run the first example.
    -   `input_file_spec.md`: A detailed reference manual for all the possible keys and values that a user can specify in the `input.yaml` file.
    -   `tutorial_alloy.md`: A tutorial walking through a complete example for an alloy system, showing the input file, the expected output, and how to interpret the results.

## 4. Implementation Approach

1.  **CLI Scaffolding:** The first step is to choose a CLI library (`typer` is recommended for its simplicity and excellent integration with type hints) and implement the basic command structure in `main.py`. A `run` command will be created that, initially, just parses the arguments, reads the `input.yaml`, and prints the parsed configuration.
2.  **Logging Setup:** The `setup_logging` function will be implemented and then called from the `run` command in the CLI. Following this, a systematic pass will be made through every existing module, replacing all `print()` statements with appropriate calls to `logging.info()`, `logging.debug()`, or `logging.warning()`. The logger object will be passed down from the orchestrator to the modules.
3.  **Orchestrator Refactoring:** The main workflow script will be refactored into a formal `Orchestrator` class. This class will be designed to be initialised with the configuration and a logger, and to be started with a single `execute()` method. This encapsulates the core logic cleanly.
4.  **Progress Bar Integration:** A progress bar library like `rich` will be chosen and integrated. The implementation will start with the highest-level loop: the active learning generations in the orchestrator. A progress bar will be added to show the progress through the generations. Subsequently, nested progress bars will be added for the most time-consuming internal loops, such as the DFT labelling process and the MD simulation steps.
5.  **Code Quality Pass:** This is a meticulous but vital step for ensuring the long-term health of the project.
    *   First, `ruff` will be run with a strict ruleset over the entire codebase, and all reported style and logic issues will be fixed.
    *   Next, a comprehensive pass will be made to add detailed docstrings to all major classes and public functions.
    *   Finally, `mypy` will be run in strict mode to find and fix any type hinting errors or inconsistencies across the entire codebase.
6.  **Documentation Writing:**
    *   The `docs` directory will be created. The initial drafts of the "Getting Started" guide and the `input.yaml` specification will be written. These are the most critical pieces of documentation for a new user.
    *   A complete, runnable tutorial for a simple system (e.g., bulk silicon or an alloy) will be written, including the exact `input.yaml` to use, the command to run, and a description of the expected output files. This tutorial will serve as both documentation and an acceptance test.

## 5. Test Strategy

Testing for Cycle 05 focuses on the user-facing CLI and the correctness of the final code quality enhancements. It's about ensuring the application is robust, reliable, and easy to use.

**Unit Testing Approach (Min 300 words):**
-   **CLI:** The CLI will be a primary focus of unit testing in this cycle. The runner provided by the chosen library (e.g., `Typer`'s `CliRunner`) will be used to invoke the CLI programmatically within `pytest`. The tests will simulate a user running the command with various arguments and options. For example, a test will run `mlip-pipe run input.yaml --verbose` and then assert that the logging level of the root logger was correctly set to `DEBUG`. Another test will provide a path to a non-existent input file and assert that the CLI exits with a non-zero status code and prints an appropriate "File not found" error message to the console. The actual execution of the `Orchestrator` will be mocked in these tests, so they remain fast and focused solely on the CLI's argument parsing and application setup logic.
-   **Logging:** While the output of logging is difficult to test directly, the `setup_logging` function can be unit-tested. The test can call the function and then inspect the properties of the root logger object to assert that the correct handlers (e.g., a `StreamHandler` and a `FileHandler`) have been attached and that they have been configured with the correct logging level and formatter.
-   **Static Analysis as Testing:** The most important form of "testing" for the code quality goals of this cycle is not `pytest`, but rather the integration of static analysis tools into the Continuous Integration (CI) pipeline. Running `ruff` and `mypy` in strict mode will become a required, passing check for all future code contributions. This automates the enforcement of code style, type hint correctness, and a wide range of best practices, effectively acting as a comprehensive suite of automated tests for code quality.

**Integration Testing Approach (Min 300 words):**
-   **CLI -> Orchestrator:** A crucial integration test will be created to verify the connection between the user interface and the core application logic. This test will invoke the CLI using the `CliRunner`. It will use a real, simple `input.yaml` file but will inject a mocked `Orchestrator` class. The test will assert that the CLI correctly instantiates the `Orchestrator` with a configuration dictionary that accurately reflects the content of the `input.yaml` file, and that it then calls the orchestrator's `execute()` method exactly once. This test verifies that the user's input is correctly parsed and passed from the command line all the way to the core application logic.
-   **Tutorial Validation as an E2E Test:** The tutorials written in the user documentation are not just text; they are a form of end-to-end integration test. A new step will be added to the CI pipeline that treats the tutorial as a test script. This CI job will execute the exact commands and use the exact `input.yaml` files described in the tutorial documents. The test will pass if the tutorial runs to completion without errors and produces the expected output files (like a trained model). This powerful technique ensures that the project's documentation is never out of sync with the actual behaviour of the software, which is a common problem in complex projects.