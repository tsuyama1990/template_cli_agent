# CYCLE 01 UAT.md: User Acceptance Testing for Core Functionality

## 1. Test Scenarios

This document outlines the User Acceptance Testing (UAT) scenarios for the successful completion of Cycle 01. The primary focus of this cycle's UAT is to rigorously verify that the core functionalities—the Command-Line Interface (CLI), the configuration system, and the initial structure generation service—are user-friendly, robust, and produce scientifically sound results. The testing process is designed to simulate a real user's experience, providing high confidence that the application is not only functional but also intuitive and reliable. The principal medium for this UAT will be a comprehensive Jupyter Notebook, provisionally named `UAT_CYCLE01_Verification.ipynb`. This interactive notebook format is chosen deliberately to serve a dual purpose: it acts as a precise, step-by-step testing script for the user, and it also serves as a piece of interactive documentation, effectively demonstrating the tool's capabilities in a hands-on manner. This approach allows users to not just read about the expected outcomes but to execute the code and see the results for themselves, providing a much higher level of assurance and a more engaging user experience.

| Scenario ID | Scenario Name                               | Priority |
| :---------- | :------------------------------------------ | :------- |
| UAT-01.01   | Successful End-to-End Generation of an Alloy | High     |
| UAT-01.02   | Robust Handling of Invalid Configurations    | High     |
| UAT-01.03   | Verification of Output File Format Integrity | Medium   |

### Scenario UAT-01.01: Successful End-to-End Generation of an Alloy

This scenario represents the primary "happy path" and the core use case for the functionality delivered in Cycle 01. The goal is to confirm that a user can successfully define a simple binary alloy system, run the pipeline from the command line, and receive a valid, multi-structure XYZ file as output. The Jupyter Notebook will guide the user through this entire process. It will begin with a Markdown cell explaining the structure of the required `config.yaml` file, followed by a code cell that programmatically writes a valid example configuration to disk. This ensures the test starts from a known, correct state. The next cell will use the `!` shell command syntax to execute the application's command-line tool, passing the path to the newly created configuration file. The output of the command will be displayed directly in the notebook. Finally, and most critically, subsequent cells will use the `ase` library to load the generated `initial_structures.xyz` file and the `nglview` library to provide an interactive 3D visualization of the generated atomic structures. This provides immediate, powerful visual feedback, allowing the user to rotate and inspect the generated supercell, confirming that the randomization of atomic species has occurred as expected and that the overall crystal structure is sound. This hands-on, visual approach is designed to be far more engaging and informative than simple text-based output, giving the user tangible confidence in the tool's core capabilities.

### Scenario UAT-01.02: Robust Handling of Invalid Configurations

A critical, yet often overlooked, aspect of user experience is how an application handles erroneous input. A robust tool should not crash; it should provide clear, actionable feedback. This scenario is designed to test the robustness and clarity of the Pydantic-based configuration validation system. The Jupyter Notebook will provide a series of code cells, each of which creates a deliberately incorrect `config.yaml` file. These test cases will cover a range of potential user errors: a configuration where the composition values do not sum to 1.0, one where a required field like `elements` is missing entirely, one where `lattice_constant` is given as a string instead of a number, and one where the elements in the `elements` list do not match the keys in the `composition` dictionary. For each of these invalid configurations, the user will execute the CLI command. The expected outcome is not a successful run, but a controlled failure. The test passes if the tool exits gracefully with a non-zero status code and, most importantly, prints a clear, informative error message to the console. The error message should explicitly state which field is invalid and why (e.g., "ValidationError: 'composition' must sum to 1.0"), allowing the user to easily diagnose and fix the problem in their own files. This scenario demonstrates that the schema-first design approach is working effectively to create a user-friendly and resilient application.

### Scenario UAT-01.03: Verification of Output File Format Integrity

This scenario ensures that the output generated by the tool is not just visually appealing but also technically sound and compliant with standard file formats used in the scientific community. While Scenario UAT-01.01 involves visualizing the output, this test focuses on the low-level technical correctness of the `initial_structures.xyz` file itself. The integrity of this output is crucial for interoperability with other scientific software. The Jupyter Notebook will guide the user to load the output file generated in the first scenario using an independent, trusted, and widely used library (ASE's `ase.io.read` function with the `index=':'` argument to load all frames). The test is considered successful if this command executes without any parsing errors and the resulting `ase.Atoms` objects in the Python list correctly and precisely reflect the properties defined in the original input configuration. This will be verified with `assert` statements in the notebook that check the number of atoms, the precise chemical symbols present, and the dimensions of the simulation cell. This programmatic verification confirms that the generated file is not just plausible but is technically sound and ready for use in the user's broader computational workflows, such as being used as an input for visualization in VMD, analysis with other Python libraries, or as a starting point for simulations in other codes.

## 2. Behavior Definitions

The expected behavior of the system for each UAT scenario is defined below with precision using the Gherkin syntax (GIVEN/WHEN/THEN). This provides an unambiguous, human-readable specification of the system's requirements.

### Behavior for UAT-01.01: Successful End-to-End Generation

**GIVEN** a user has created a complete and valid `config.yaml` file for a Copper-Gold (CuAu) alloy with the following specific properties:
- `generation.elements`: `['Cu', 'Au']`
- `generation.composition`: `{'Cu': 0.5, 'Au': 0.5}`
- `generation.lattice_constant`: `3.8`
- `generation.num_structures`: `5`
- `generation.supercell_size`: `[2, 2, 2]`
**AND** the current working directory is writable.

**WHEN** the user executes the command `mlip-autopipec run --config-path config.yaml` in their terminal.

**THEN** the command should complete successfully and exit with a status code of 0.
**AND** a success message should be printed to the standard output.
**AND** a new file named `initial_structures.xyz` should be created in the current working directory.
**AND** this file, when inspected, should contain exactly 5 distinct atomic structure configurations.
**AND** each structure within the file should be composed of exactly 32 atoms (resulting from a 2x2x2 supercell expansion of a 4-atom primitive FCC cell).
**AND** each of these structures should contain precisely 16 Copper (Cu) atoms and 16 Gold (Au) atoms, reflecting the 50/50 composition.

### Behavior for UAT-01.02: Robust Handling of Invalid Configurations

**GIVEN** a user has created an intentionally invalid `config.yaml` file where the composition fractions sum to 1.1, which is physically impossible:
- `generation.elements`: `['Cu', 'Au']`
- `generation.composition`: `{'Cu': 0.6, 'Au': 0.5}`

**WHEN** the user executes the command `mlip-autopipec run --config-path config.yaml`.

**THEN** the command must fail and exit with a non-zero status code, indicating an error.
**AND** the application must print a clear and informative error message to the standard error stream.
**AND** this error message must explicitly indicate a `ValidationError` has occurred.
**AND** the error message must contain human-readable text that precisely identifies the source of the error, such as "The sum of composition values must be equal to 1.0".
**AND** no output file named `initial_structures.xyz` should be created.

### Behavior for UAT-01.03: Verification of Output File Format Integrity

**GIVEN** a valid `initial_structures.xyz` file has been successfully generated by the application.

**WHEN** a user or an external script loads this file using a standard, independent analysis library, for example, by executing the Python code: `from ase.io import read; atoms_list = read('initial_structures.xyz', index=':')`.

**THEN** the `read` function call should execute without raising any file parsing errors or exceptions.
**AND** the returned variable `atoms_list` should be a standard Python `list`.
**AND** each item within this list should be a valid `ase.Atoms` object.
**AND** the total length of the `atoms_list` must be exactly equal to the `num_structures` value specified in the original configuration file.
**AND** the `get_cell()` method of each `ase.Atoms` object in the list must return a cell matrix whose dimensions correspond correctly to the specified `lattice_constant` and `supercell_size` from the configuration.
