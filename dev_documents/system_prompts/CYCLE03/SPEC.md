# Cycle 3 Specification: Advanced Sampling and Hybrid Exploration

## 1. Summary

Cycle 3 significantly enhances the scientific sophistication of the MLIP-AutoPipe. Where Cycle 2 introduced the raw power of MD simulation, Cycle 3 refines it by adding intelligence in two key areas: more efficient exploration of the potential energy surface and smarter selection of training data.

The primary deliverables for this cycle are:
1.  **Implementation of a `SamplingEngine`:** This new engine will be responsible for processing the large number of atomic configurations generated during exploration and selecting a smaller, more valuable subset. This is a critical step for creating efficient and effective training datasets.
2.  **Introduction of Advanced Sampling Strategies:** The `SamplingEngine` will host different sampling algorithms. This cycle will implement two key methods:
    *   **`RandomSampler`:** A baseline strategy that randomly selects a configured number of structures from the trajectories.
    *   **`FPSSampler` (Farthest Point Sampling):** A much more advanced technique that aims to maximize the diversity of the selected structures. This involves computing a "fingerprint" (a vector of numbers describing the local atomic environment) for each structure and then iteratively selecting the structure that is most different from those already chosen.
3.  **Enhancement of the Exploration Engine with Hybrid MD/MC:** The exploration capability will be upgraded to support hybrid Molecular Dynamics / Monte Carlo (MD/MC) simulations. Specifically, this involves adding a Monte Carlo "atom swap" move that can be attempted periodically during a standard MD run. This technique is extremely powerful for accelerating the exploration of chemical configuration space in materials like alloys, allowing the system to find new arrangements that would be very slow to reach via pure MD.

By the end of Cycle 3, the pipeline will be far more powerful. Instead of just producing raw simulation data, it will be able to intelligently curate that data into a diverse, high-quality training set. The addition of hybrid MD/MC will make the exploration phase more efficient, leading to the discovery of more interesting and relevant atomic configurations in less simulation time.

## 2. System Architecture

This cycle introduces a new `samplers` module and a new `SamplingEngine`, while also modifying the `explorers` module to support MC moves. Files to be created or modified are in **bold**.

```
src/mlip_autopipec/
├── __init__.py
├── **config.py**               # Pydantic models updated for sampling and hybrid MD/MC
├── database/
│   ├── __init__.py
│   └── **ase_db_wrapper.py**   # Updated to store final sampled dataset
├── domain/
│   ├── __init__.py
│   ├── models.py
│   └── interfaces.py
├── engines/
│   ├── __init__.py
│   ├── generation_engine.py
│   ├── exploration_engine.py
│   ├── **sampling_engine.py**    # **New implementation**
│   └── storage_engine.py     # Now consumes data from SamplingEngine
├── explorers/
│   ├── __init__.py
│   └── **md_mc_explorer.py**     # Enhanced with MC swap move logic
├── generators/
│   # ... (no changes)
├── **samplers/**
│   ├── **__init__.py**
│   ├── **base_sampler.py**       # **New** base class for samplers
│   ├── **random_sampler.py**     # **New** implementation
│   └── **fps_sampler.py**        # **New** implementation
├── utils/
│   └── __init__.py
└── **workflow_orchestrator.py**  # Updated to call the SamplingEngine
```

**File Blueprints:**

*   **`config.py`**:
    *   A new `SamplingConfig` Pydantic model will be added to `MainConfig`. It will contain a `mode` field (`"random"` or `"fps"`) and a `num_samples` field.
    *   The `ExplorationConfig` will be updated with a new `mc_swap_frequency` field to control how often to attempt atom swaps during MD.

*   **`database/ase_db_wrapper.py`**:
    *   A new method, `get_all_explored_trajectories()`, will be added to retrieve the file paths of all trajectories generated by the exploration stage.
    *   The `write_atoms` method will be updated or a new method `write_final_dataset` will be created to save the *final* sampled structures, potentially with additional metadata indicating they are part of the curated set.

*   **`explorers/md_mc_explorer.py`**:
    *   The `run_md_simulation` function will be refactored into a class, `HybridMDMC`, to better manage the state of the simulation.
    *   The main simulation loop will be modified. Every `mc_swap_frequency` steps, it will pause the MD integration, call a new private method `_attempt_atom_swap()`, and then resume the MD.
    *   `_attempt_atom_swap()` will implement the Monte Carlo logic: randomly select two atoms of different species, calculate the change in potential energy (ΔE) if they were swapped, and accept the swap based on the Metropolis criterion (accept if ΔE < 0, or with probability `exp(-ΔE / kT)` if ΔE > 0).

*   **`samplers/base_sampler.py`**:
    *   A new abstract base class `BaseSampler` will be defined with an abstract method `sample(self, trajectories: list[str]) -> list[ase.Atoms]`.

*   **`samplers/random_sampler.py`**:
    *   `RandomSampler` will inherit from `BaseSampler`.
    *   Its `sample` method will read all atoms from all trajectory files, pool them together, and use Python's `random.sample` to select the desired number of structures.

*   **`samplers/fps_sampler.py`**:
    *   `FPSSampler` will inherit from `BaseSampler`. This is the most complex component of this cycle.
    *   The `sample` method will:
        1.  Read a subset of atoms from the trajectories to create a candidate pool.
        2.  For each atom in the pool, compute its SOAP fingerprint using a library like `dscribe`. This converts each atomic structure into a high-dimensional vector.
        3.  Implement the FPS algorithm:
            a.  Select the first structure randomly.
            b.  Iteratively, for all remaining candidates, calculate their "distance" (e.g., Euclidean distance in fingerprint space) to the nearest already-selected structure.
            c.  Select the candidate with the maximum minimum-distance and add it to the final set.
            d.  Repeat until `num_samples` have been selected.

*   **`engines/sampling_engine.py`**:
    *   The `SamplingEngine` class will be implemented.
    *   Its `run()` method will:
        1.  Read the `SamplingConfig`.
        2.  Instantiate the correct sampler (`RandomSampler` or `FPSSampler`) based on the `mode`.
        3.  Call the DB wrapper to get the list of all trajectory files.
        4.  Call the sampler's `sample()` method to get the final list of `ase.Atoms` objects.
        5.  Return this list.

*   **`workflow_orchestrator.py`**:
    *   The `run()` method will be updated to call the `SamplingEngine` after the `ExplorationEngine`. The output from the sampling engine will then be passed to the `StorageEngine`.

## 3. Design Architecture

The design for this cycle focuses on encapsulating complex algorithms (like FPS) into swappable components and cleanly integrating them into the existing pipeline.

**Pydantic Models (`config.py`):**

The configuration will be extended to give the user control over the new features.

```python
from pydantic import BaseModel, Field
from typing import Optional, Literal

# ... existing configs ...

class MCSwapConfig(BaseModel):
    """Configuration for Monte Carlo atom swaps."""
    swap_frequency: int = Field(20, gt=0, description="Attempt a swap every N steps.")

class ExplorationConfig(BaseModel):
    # ... existing fields ...
    mc_swap: Optional[MCSwapConfig] = None

class SamplingConfig(BaseModel):
    """Configuration for the Sampling stage."""
    mode: Literal["random", "fps"] = Field("random", description="Sampling strategy to use.")
    num_samples: int = Field(100, gt=0, description="Number of structures to select for the final dataset.")
    # Add FPS-specific parameters here in the future

class MainConfig(BaseModel):
    # ... existing fields ...
    exploration: Optional[ExplorationConfig] = None
    sampling: Optional[SamplingConfig] = None
```

**Design Principles:**

*   **Strategy Pattern:** The design of the `SamplingEngine` is a classic example of the Strategy Pattern. The engine itself doesn't know the details of *how* sampling is done. It simply holds a reference to a `BaseSampler` object and calls its `sample` method. This makes the system extremely extensible: to add a new sampling method, one only needs to create a new class that inherits from `BaseSampler` and implement the `sample` method. The engine and orchestrator require no changes.
*   **Encapsulation of Complexity:** The Farthest Point Sampling algorithm is mathematically and computationally intensive. All of this complexity is hidden away (encapsulated) within the `FPSSampler` class. The rest of the system is completely unaware of SOAP vectors, distance metrics, or the iterative selection process. It simply provides the sampler with trajectory files and receives a list of atoms in return. This makes the overall system much easier to reason about.
*   **Composition over Inheritance:** The hybrid MD/MC functionality is added through composition. Instead of creating a complex class hierarchy for different dynamics modes, the `HybridMDMC` class will *contain* an instance of a standard ASE dynamics integrator (like `Langevin`) and will call its `run()` method for short bursts, intervening with the MC logic between these bursts. This is a more flexible and robust design.

## 4. Implementation Approach

The implementation will be tackled in three main parts: Hybrid MD/MC, the sampling framework, and finally the FPS algorithm.

1.  **Hybrid MD/MC (`md_mc_explorer.py`):**
    *   Refactor the existing `run_md_simulation` function into a `HybridMDMC` class.
    *   The constructor `__init__` will set up the ASE dynamics object, calculator, and trajectory logger.
    *   Create a `run()` method that contains the main simulation loop.
    *   Inside the loop, call `dyn.run(mc_swap.swap_frequency)` to perform a chunk of MD.
    *   After the MD chunk, call a new `_attempt_atom_swap()` method. This method will contain the logic for selecting atoms, calculating the energy before and after the proposed swap, and applying the Metropolis criterion.

2.  **Sampling Framework (`SamplingEngine`, `BaseSampler`, `RandomSampler`):**
    *   Create the `samplers` directory and the base class/interface.
    *   Implement the `RandomSampler` first, as it is simple and can be used to test the engine's integration.
    *   Implement the `SamplingEngine`, which selects the strategy based on the config and calls it.
    *   Update the `WorkflowOrchestrator` and `AseDBWrapper` to plumb the new engine into the pipeline. At this point, the entire pipeline should be runnable with `mode: "random"`.

3.  **FPS Implementation (`FPSSampler`):**
    *   Add `dscribe` as a new project dependency.
    *   Implement the `FPSSampler` class.
    *   Write the logic to set up the SOAP descriptor from `dscribe.descriptors.SOAP`.
    *   Write the code to iterate through structures, create the fingerprint vectors for each one, and store them in a NumPy array.
    *   Implement the core FPS iterative selection algorithm. This part is performance-sensitive, so care must be taken to use vectorized NumPy operations where possible to calculate distances efficiently.

## 5. Test Strategy

Testing this cycle's features requires verifying both the statistical correctness of the new algorithms and their proper integration.

**Unit Testing Approach (Min 300 words):**

*   **Hybrid MD/MC:** We will unit test the `_attempt_atom_swap` logic in isolation. We can create a test scenario with a simple 2-atom system (`HHe`). We will attach a mock calculator that returns a predictable energy.
    1.  Test 1: Configure the mock calculator so that the energy *decreases* after the swap. Assert that the swap is always accepted and the atom positions are changed.
    2.  Test 2: Configure the mock so the energy *increases* significantly. By running the function many times, we can assert that the swap is rejected most of the time. This verifies the Metropolis criterion logic.
*   **`RandomSampler`:** This test is straightforward. We will create a few dummy trajectory files containing a known total number of structures (e.g., 3 files with 10 structures each = 30 total). We will run the `RandomSampler` configured to select 5 samples. We will assert that the output is a list of 5 `ase.Atoms` objects.
*   **`FPSSampler`:** Testing FPS requires a deterministic setup. We will create a small, simple set of "structures" represented by 1D vectors (e.g., `[1], [2], [10], [11]`).
    1.  We will run the FPS algorithm to select 2 samples. The algorithm should deterministically select the two endpoints, `[1]` and `[11]`, as they are farthest apart.
    2.  We will run it to select 3 samples. It should select `[1]`, `[11]`, and then `[2]` or `[10]`. We can assert that the final set contains the two endpoints. This verifies the core logic of maximizing diversity.

**Integration Testing Approach (Min 300 words):**

Two main integration tests will be performed, one for each major new feature.
*   **Hybrid MD/MC Test:**
    1.  A test will be set up with a binary alloy configuration (e.g., CuAu).
    2.  The exploration config will enable `mc_swap` with a high frequency (e.g., every 5 steps) to ensure it runs many times during a short simulation.
    3.  We will run the pipeline through the exploration stage.
    4.  To verify it worked, we need a way to track the swaps. The `HybridMDMC` class can be temporarily modified to log every accepted swap. The test will then assert that this log is not empty. A more sophisticated check could involve analyzing the atomic positions in the trajectory to find evidence of a swap having occurred.
*   **FPS Sampling Test:**
    1.  A test will be configured to run the full pipeline: Generate -> Explore -> Sample.
    2.  The sampling stage will be configured with `mode: "fps"` and `num_samples: 10`.
    3.  The exploration stage will be configured to produce a reasonable number of candidate structures (e.g., 100).
    4.  The pipeline is executed.
    5.  **Assertions:**
        a. The final database should contain exactly 10 structures marked as part of the final dataset.
        b. We will then run the pipeline a second time, but change the sampling `mode` to `"random"`.
        c. We will then compare the two resulting datasets. We can calculate the average pairwise "distance" between structures in the FPS-generated set and the randomly-generated set. We will assert that the average distance is significantly higher for the FPS set, providing quantitative proof that it is indeed producing a more diverse dataset.
