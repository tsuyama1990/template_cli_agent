# UAT.md for CYCLE02: Automation, Active Learning & Advanced Simulation

## 1. Test Scenarios

This document outlines the User Acceptance Tests (UAT) for CYCLE02. The successful completion of this cycle marks the delivery of a fully autonomous pipeline that fulfills the project's core vision: removing the human expert from the loop. The UAT for this final cycle is, therefore, laser-focused on verifying this "fire-and-forget" capability. A user should be able to initiate a highly complex, multi-stage workflow with a minimal, high-level input file and, after some period of computation, receive a high-quality, validated potential without any further manual intervention. To this end, the primary test scenario is a complete, unattended, automated run for a scientifically relevant and complex real-world material: the magnetic alloy Iron-Platininum (FePt). This choice is deliberate, as it demonstrates the system's ability to autonomously handle complex physics, such as magnetism and the disordered structures of alloys, without requiring expert user guidance. A secondary, but equally important, test scenario focuses on the user experience of the `ConfigExpander`, ensuring that its heuristic-driven approach provides intelligent and physically sensible defaults, genuinely simplifying the user's interaction with the system.

*   **Scenario ID**: UAT-C02-01
*   **Priority**: High
*   **Title**: Fully Autonomous End-to-End Workflow for a Complex Binary Alloy (FePt)
*   **Description**: This is the capstone test of the entire system's capabilities, designed to validate the integration and correct operation of all modules in a fully autonomous mode. The user will initiate the test by creating a minimal `input.yaml` file that specifies only the constituent elements ("Fe", "Pt") and the composition ("FePt"). They will then execute the single, unified `run` command. From this point forward, the system must perform all subsequent steps without any human intervention. This includes: invoking the `ConfigExpander` to generate a complete and physically-sound execution plan; calling the `StructureGenerator` to create a diverse initial set of SQS (Special Quasirandom Structures) to represent the alloy; using the `ExplorerSampler` with its MACE surrogate model to efficiently explore the vast potential energy landscape; selecting and queuing the most informative structures for high-fidelity DFT labeling; automatically handling the magnetic properties of FePt during the DFT calculations; training an initial ACE potential; and, most critically, running an on-the-fly simulation that actively detects regions of high model uncertainty and iteratively adds new structures to the training set to refine the potential over several generations. The test is considered a success if this entire, long-running process completes without errors or crashes and produces a final, refined `.ace` potential file. The validity and quality of this final artifact will be qualitatively checked by using it to run a short, independent molecular dynamics simulation and observing stable, physically realistic behavior.

*   **Scenario ID**: UAT-C02-02
*   **Priority**: Medium
*   **Title**: Verification of User Experience and Intelligence of the Minimal Configuration Expander
*   **Description**: This test is designed to verify the usability, intelligence, and overall user experience provided by the `ConfigExpander` module. While UAT-C02-01 tests the full pipeline, this test focuses on the very first step, ensuring that it provides a real and valuable abstraction for the user. The user will provide the same minimal `input.yaml` for FePt as in the main scenario and then inspect the `exec_config_dump.yaml` file that is automatically generated by the `ConfigExpander` at the beginning of the run. The test is considered successful if this generated configuration file contains physically reasonable, non-default values for critical parameters that were not specified by the user. Specifically for the FePt case, the `dft_compute` settings must automatically and correctly enable magnetism (`magnetism: "ferromagnetic"`), and the cutoff energies (`ecutwfc`, `ecutrho`) must be set to values appropriate for the Fe and Pt pseudopotentials as recommended by a standard protocol like SSSP. This test provides direct evidence that the system's internal heuristics are working correctly and are genuinely simplifying the user's task by handling complex, material-specific details automatically. It confirms that the system is not merely running with generic defaults but is actively tailoring its execution plan to the specific problem defined by the user.

## 2. Behavior Definitions

The expected behavior of the fully automated system is defined below using the Gherkin-style syntax to ensure clarity, precision, and a focus on the user's perspective.

---

### **Scenario: UAT-C02-01 - Fully Autonomous Workflow for a Complex Material**

**GIVEN** a user is in a clean working directory
**AND** a valid, executable Quantum Espresso `pw.x` binary is available in the system's PATH
**AND** the user has created a minimal, high-level configuration file named `input.yaml` with the following simple content:
```yaml
elements: ["Fe", "Pt"]
composition: "FePt"
```

**WHEN** the user executes the single, unified command to start the entire autonomous workflow:
`mlip-pipe run input.yaml`

**THEN** the command should immediately start the autonomous workflow and begin printing clear, human-readable progress updates to the console for each major stage (e.g., "Stage 1/5: Generating initial structures...", "Stage 2/5: Running exploration phase with MACE...", "Stage 3/5: Starting active learning generation 1 of 10...").
**AND** at the outset of the run, the system must create a detailed `exec_config_dump.yaml` file, which contains the full, heuristically-determined configuration, making the run fully transparent and reproducible.
**AND** a database file (e.g., `mlip_run.db`) should be created and should be observed to grow in size as it is gradually populated with new atomic structures and their corresponding DFT labels across multiple active learning generations.
**AND** the workflow must proceed for the entire configured number of active learning generations without crashing, hanging, or requiring any form of user input.
**AND** upon successful completion of all stages, the command must exit gracefully with a status code of 0.
**AND** a final, trained potential file, clearly named (e.g., `FePt_final.ace`), must be created in the working directory.
**AND** this final potential file must be a valid and usable artifact that can be loaded into an external analysis tool (specifically, ASE) to run a short but stable molecular dynamics simulation of an FePt crystal, confirming its physical viability.

---

### **Tutorial Notebook: `UAT-C02-Autonomous-Workflow-Tutorial.ipynb`**

This Jupyter Notebook will serve as the master test script for the final, autonomous system. It provides an executable, step-by-step guide that not only verifies the system's functionality but also serves as a primary piece of documentation and a tutorial for new users.

```python
# UAT-C02: A Tutorial and Verification Notebook for the Fully Autonomous Workflow

import os
import subprocess
import time
import yaml
from ase.io import read
from ase import build
from ase.calculators.ace import ACE
from ase.md.velocitydistribution import MaxwellBoltzmannDistribution
from ase.md.verlet import VelocityVerlet
from ase import units

# --- 1. SETUP: THE MINIMAL USER INPUT ---
# The goal of this cycle is to minimize user effort. All the user needs to provide is this one file.

print("--- Step 1: Setting up the minimal input file ---")

# We choose FePt, a scientifically interesting and complex magnetic alloy, as our test case.
minimal_yaml_content = """
elements: ["Fe", "Pt"]
composition: "FePt"
"""
with open("input.yaml", "w") as f:
    f.write(minimal_yaml_content)

print("Successfully created the minimal 'input.yaml' for our FePt test case.")
print("Setup is complete. The system should handle everything else.")

# --- 2. EXECUTE THE AUTONOMOUS WORKFLOW ---
# This single command should run the entire, multi-hour pipeline.
# It is the primary entry point for the entire application.

print("\n--- Step 2: Running the main 'run' command ---")
print("This will start the full autonomous pipeline. It is expected to be a long-running process...")

run_command = ["mlip-pipe", "run", "input.yaml"]

# In a real use case, a user would run this and leave it. For this test, we monitor its output.
# For an automated CI/CD run, this process would have a very long timeout.
process = subprocess.Popen(run_command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True)

# We can monitor the output in real-time to see the progress logging.
while process.poll() is None:
    line = process.stdout.readline().strip()
    if line:
        print(f"[Workflow Log] {line}")
    time.sleep(0.1) # Avoid busy-waiting

# After the process finishes, capture any remaining output.
stdout, stderr = process.communicate()
if stdout:
    print(stdout)
if stderr and "error" in stderr.lower(): # Be more selective about printing stderr
    print(f"Captured Stderr: {stderr}")


assert process.returncode == 0, f"Autonomous run failed with a non-zero exit code! Check the logs for errors."
print("Autonomous workflow command executed successfully.")

# --- 3. VERIFY THE OUTPUT ARTIFACTS ---
# After a successful run, we must check that all the expected final files have been created.

print("\n--- Step 3: Verifying the output artifacts ---")

# a) Check for the expanded configuration file, which ensures transparency.
assert os.path.exists("exec_config_dump.yaml"), "Assertion Failed: The full config dump file was not created!"
print("Verified: Found 'exec_config_dump.yaml'.")

# b) Check that the database was created and populated.
assert os.path.exists("mlip_run.db"), "Assertion Failed: The database file was not created!"
print("Verified: Found the 'mlip_run.db' database file.")

# c) The most important artifact: the final potential.
assert os.path.exists("FePt_final.ace"), "Assertion Failed: The final ACE potential file was not created!"
print("Verified: Found the final 'FePt_final.ace' potential.")

# d) Perform the UAT-C02-02 check on the expanded config.
with open("exec_config_dump.yaml", "r") as f:
    full_config = yaml.safe_load(f)
assert full_config["dft_compute"]["magnetism"] == "ferromagnetic", "ConfigExpander intelligence check failed: Magnetism was not auto-enabled for FePt."
print("Verified: ConfigExpander correctly set magnetism for FePt.")


# --- 4. QUALITATIVE VALIDATION OF THE GENERATED POTENTIAL ---
# The ultimate test of the entire workflow: does the potential it produced describe the physics
# of the material in a stable and reasonable way?

print("\n--- Step 4: Performing a qualitative validation MD run with the new potential ---")

try:
    # a) Load the potential that the pipeline just created.
    calc = ACE("FePt_final.ace")

    # b) Create a representative test structure. The L1_0 ordered phase is a good choice for FePt.
    # We build a supercell to have enough atoms for a meaningful simulation.
    atoms = build.bulk('FePt', 'l10', a=3.8, cubic=True) * (3, 3, 3)

    # c) Assign the newly-created potential to our test structure.
    atoms.set_calculator(calc)

    # d) Initialize velocities to 300K and run a short MD simulation.
    MaxwellBoltzmannDistribution(atoms, temperature_K=300)
    dyn = VelocityVerlet(atoms, 1.0 * units.fs) # Use a 1 fs timestep.

    print("Starting a short NVE molecular dynamics simulation for stability check...")

    def print_dynamics_state():
        potential_energy = atoms.get_potential_energy() / len(atoms)
        kinetic_energy = atoms.get_kinetic_energy() / len(atoms)
        current_temp = atoms.get_temperature()
        print(f"Step {dyn.get_number_of_steps()}: E_pot/atom = {potential_energy:.3f} eV, E_kin/atom = {kinetic_energy:.3f} eV, Temp = {current_temp:.1f} K")

    dyn.attach(print_dynamics_state, interval=25)
    dyn.run(250) # Run for 250 steps (0.25 picoseconds).

    print("\nMD simulation finished.")
    # For a simple stability check, we verify that the energy didn't explode and the temperature is stable.
    final_temp = atoms.get_temperature()
    assert 150 < final_temp < 450, f"Final temperature ({final_temp} K) is out of the expected range, which may indicate an unstable potential."

except Exception as e:
    assert False, f"FATAL: Failed to run the validation MD simulation. The generated potential may be invalid. Error: {e}"

print("\nUAT-C02-01 PASSED: The autonomous workflow completed successfully, and the final potential is stable in a test simulation.")
```

---

### **Scenario: UAT-C02-02 - Config Expander Intelligence Verification**

**GIVEN** a user is in a clean working directory
**AND** the user has created the same minimal `input.yaml` for the FePt system as in the previous scenario.

**WHEN** the user executes the main command: `mlip-pipe run input.yaml`
**AND** the user observes the file system and waits for the `exec_config_dump.yaml` file to be created, which should happen within the first few seconds of the run.
**AND** the user then immediately terminates the `mlip-pipe` process (e.g., with Ctrl+C).

**THEN** the `exec_config_dump.yaml` file must exist in the directory.
**AND** when the user opens and inspects this YAML file, the `dft_compute` section must contain the key-value pair `magnetism: "ferromagnetic"` (or a more complex, but still magnetic, setting), which was not specified in the minimal input but was correctly inferred by the system.
**AND** the `ecutwfc` value in the file must be a physically reasonable number for the Fe and Pt elements (e.g., greater than 60 Rydberg), demonstrating that the system has applied a known DFT protocol.
**AND** the `active_learning` section must be fully populated with default strategies and parameters, demonstrating that the system is ready to run the full loop.

This test provides a quick and direct confirmation that the system is correctly applying its internal, codified expertise to expand the user's simple request into a complete, physically-sensible, and reproducible execution plan.
