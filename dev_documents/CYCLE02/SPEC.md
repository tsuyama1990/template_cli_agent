# CYCLE02 Specification: Automated Structure Generation and Configuration Expansion

## 1. Summary

CYCLE02 represents a major leap forward in the automation of the MLIP-AutoPipe system. The central theme of this cycle is the elimination of manual data preparation. While CYCLE01 established the core processing pipeline, it still required the user to provide a set of pre-made atomic structures. This cycle removes that dependency by implementing the Structure Generator (Module A) and the Config Expander heuristic engine.

The primary goal is to enable the system to generate its own diverse and physically relevant initial training data, starting from nothing more than a chemical formula (e.g., "FePt") or a single structure file. Module A will be implemented with several specialized generators tailored to different material types. It will automatically classify the input system into categories (Alloy, Molecular, Ionic, Covalent) and then apply the most appropriate generation strategy, such as Special Quasirandom Structures (SQS) for alloys or Normal Mode Sampling (NMS) for molecules.

Complementing this is the development of the Config Expander, the heuristic engine that powers the Two-Tier Configuration strategy. This engine will take a minimal `input.yaml` from the user and intelligently expand it into the comprehensive `exec_config_dump.yaml`. It will automate the selection of dozens of complex parameters, such as inferring the optimal DFT cutoffs and k-point densities from the SSSP protocol, predicting a reasonable temperature range for simulations based on estimated melting points, and selecting appropriate baseline potentials. This cycle's work moves the project significantly closer to its core vision of "removing the human expert from the loop" by embedding expert knowledge directly into the software.

## 2. System Architecture

The architecture in CYCLE02 expands upon the linear pipeline of CYCLE01 by prepending the new automated generation and configuration modules. The workflow now begins with the user's minimal input and autonomously prepares the full context needed for the subsequent labeling and training stages.

The enhanced data flow is as follows:
1.  **User Input**: The user provides a minimal `input.yaml` containing only the system's elemental composition (e.g., `composition: "Si"`).
2.  **Config Expansion**: The `ConfigExpander` heuristic engine is the first component to run.
    *   It parses the minimal config.
    *   It performs material analysis (e.g., classifies "Si" as a covalent material).
    *   It infers a wide range of parameters: it might select a Melt-Quench protocol for structure generation, determine the correct SSSP pseudopotentials for Si, calculate the required plane-wave cutoffs, and set a default k-point density.
    *   It writes the complete `exec_config_dump.yaml` file to disk. This file is now the single source of truth for the rest of the workflow.
3.  **Structure Generation (Module A)**: The `StructureGenerator` is invoked.
    *   It reads the `exec_config_dump.yaml` to determine which generation strategy to use (e.g., Melt-Quench).
    *   It executes the chosen algorithm, producing a set of diverse ASE `Atoms` objects. These structures are held in memory for the next stage.
4.  **Labeling and Training (Modules C & D)**: The workflow proceeds exactly as in CYCLE01, but instead of using user-provided structures, it uses the set of structures generated by Module A. These structures are passed to the `LabelingEngine`, and the rest of the process (DFT calculation, database storage, training) remains the same.

The user interaction is simplified significantly. The CLI command no longer requires a path to a directory of structures, as the system now creates its own. The command becomes `uv run mlip-pipe run input.yaml`.

## 3. Design Architecture

This cycle introduces two major new components into the `src/mlip_autoprope/` directory: the `heuristics` package and the `a_structure_generator` module.

**Key Files and Classes:**

*   `src/mlip_autoprope/heuristics/expander.py`:
    *   `ConfigExpander` class: This will be the main class for the heuristic engine.
    *   `run(input_config)`: The main public method that takes the parsed minimal config and returns a fully populated `ExecConfig` object.
    *   `_classify_material(composition)`: A private method that uses libraries like `pymatgen` to analyze the elements and determine the material type (Alloy, Molecular, etc.).
    *   `_get_dft_params(elements)`: A method to look up SSSP recommendations for pseudopotentials, cutoffs, etc., for the given elements.
    *   `_get_generation_strategy(material_type)`: A method that maps the material type to a default structure generation protocol.
*   `src/mlip_autoprope/modules/a_structure_generator.py`:
    *   `StructureGenerator` class: The main orchestrator for this module. Its `run` method will act as a router, calling the appropriate specific generator.
    *   `_run_sqs(config)`: A private method to handle SQS generation for alloys. It will likely wrap an external library like `icet`.
    *   `_run_nms(config)`: A private method for Normal Mode Sampling for molecules.
    *   `_run_airss(config)`: A private method for random structure searching for ionic materials.
    *   `_run_melt_quench(config)`: A private method for generating covalent/amorphous structures. This will require a basic MD loop using a simple, fast potential (e.g., from ASE's built-in calculators).
*   `src/mlip_autoprope/config/core.py`: The Pydantic models will be updated. `InputConfig` will be simplified to its minimal form. `ExecConfig` will be expanded to include new sections for `structure_generation` with parameters for each strategy.
*   `src/mlip_autoprope/cli.py`: The CLI will be modified to remove the `--structures-dir` argument and instead initialize the new `ConfigExpander` and `StructureGenerator` at the beginning of the `run` command's logic.

The dependency list in `pyproject.toml` will be expanded to include `pymatgen` for material analysis and potentially `icet` for SQS generation.

## 4. Implementation Approach

1.  **Update Configuration**: First, refactor the Pydantic models in `config/core.py`. Define the new, simpler `InputConfig` and add the `structure_generation` section to the `ExecConfig`.
2.  **Implement Heuristic Engine**:
    *   Create the `ConfigExpander` class skeleton.
    *   Implement the `_classify_material` method first. This is a key decision point for the other heuristics. Use `pymatgen`'s element data to make these classifications.
    *   Implement the DFT parameter logic (`_get_dft_params`). This may involve parsing data files from a library like `sssp_tools` or creating a simple internal database of SSSP recommendations.
    *   Implement the `run` method to tie these pieces together, constructing the full `ExecConfig` object.
3.  **Implement Structure Generators**:
    *   Implement the `StructureGenerator` class, starting with the main `run` method that acts as a router.
    *   Implement each generation method (`_run_sqs`, `_run_nms`, etc.) one by one. Each method should be a self-contained unit.
    *   For methods involving external tools (`icet`), write a clear wrapper that handles input/output conversion to and from ASE `Atoms` objects.
    *   For the `_run_melt_quench` method, use ASE's `Langevin` or similar dynamics integrators with a simple calculator like `EMT` to simulate the process.
4.  **Integrate into CLI**:
    *   Modify the `run` command in `cli.py`.
    *   The new logic will be: Parse `InputConfig` -> Instantiate and run `ConfigExpander` to get `ExecConfig` -> Instantiate and run `StructureGenerator` to get `initial_structures` -> Pass structures and `ExecConfig` to the existing `LabelingEngine` and `TrainingEngine`.
5.  **Testing**: Throughout the process, add unit tests for each component. Test the classifier, the heuristic rules, and each individual structure generator to ensure they produce valid outputs.

This modular approach allows for the incremental development and testing of each new component before integrating it into the main application workflow.

## 5. Test Strategy

Testing for CYCLE02 is crucial to validate the automation logic and ensure the generated structures are physically sensible.

### Unit Testing Approach

*   **Heuristic Engine**: This is the most critical component to unit test.
    *   Create a series of minimal `input.yaml` files for different chemical systems (e.g., "FePt", "H2O", "NaCl", "C").
    *   For each input, run the `ConfigExpander` and assert that the resulting `ExecConfig` object has the correct `material_type`.
    *   Assert that the DFT parameters in the output config are reasonable (e.g., `ecutwfc` for FePt is higher than for H2O).
    *   Assert that the chosen `generation_strategy` is appropriate for the material type.
*   **Structure Generators**: Each generator must be tested in isolation.
    *   **SQS**: For a given input like "FePt", call the SQS generator and verify that the output is a list of ASE `Atoms` objects, each with the correct 50/50 stoichiometry and no overlapping atoms.
    *   **NMS**: For a water molecule, verify that the generated structures show bond stretching and angle bending modes.
    *   **Melt-Quench**: For carbon, verify that the final structure is amorphous (e.g., by checking its radial distribution function) and has a reasonable density. Check that atoms are not unphysically close.

### Integration Testing Approach

*   **Config to Generation**: Test the link between the heuristic engine's output and the structure generator's input. Run the `ConfigExpander` for "FePt" and ensure the output `ExecConfig` correctly triggers the `SQS` method (and not NMS) within the `StructureGenerator`.
*   **Generation to Labeling**: Test that the list of ASE `Atoms` objects produced by a generator (e.g., SQS for FePt) can be correctly passed to the `LabelingEngine` from CYCLE01 and that the DFT calculations start without errors related to malformed structures.
*   **Full End-to-End Test**: This is the key UAT for this cycle.
    1.  Create a minimal `input.yaml` for a simple, well-behaved system like silicon (Si).
    2.  Run the full CLI command: `uv run mlip-pipe run input.yaml`.
    3.  Verify the entire workflow completes successfully: the `ConfigExpander` correctly identifies Si as covalent, the `StructureGenerator` creates a set of rattled/deformed Si structures, the `LabelingEngine` calculates their DFT properties, and the `TrainingEngine` produces a final MLIP model. This test validates that all new components are correctly integrated into the existing pipeline.
