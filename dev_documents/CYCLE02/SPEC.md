# Cycle 02 Specification: Structure Generation and Configuration

## 1. Summary

This document outlines the technical specifications for Cycle 02 of the MLIP-AutoPipe project. The primary goal of this cycle is to build the intelligent "front-end" of the pipeline, a crucial step in fulfilling the project's core philosophy of "removing the human expert from the loop." This will move the system from a manually-fed workflow, which relies on user-provided structures, to one that can be initiated with minimal, high-level user input. This objective will be achieved by implementing two key, synergistic features: the **Structure Generator** module and the **"Two-Tier Configuration"** strategy. The former automates the scientific task of creating an initial dataset, while the latter automates the technical task of setting up the calculation parameters, and together they form the basis of the system's autonomy.

The Structure Generator is responsible for creating a diverse and physically plausible set of initial atomic structures, which will serve as the first batch of candidates for the MLIP training dataset. This module is critical as it automates the crucial but often intuitive process of selecting what initial structures to sample, a task that has traditionally fallen to experienced researchers. The generator will be designed to be context-aware, using a heuristic engine to automatically identify the type of material (e.g., alloy, molecule, ionic crystal) based on its chemical composition. It will then apply the most appropriate and physically sound structure generation algorithm for that material type, such as Special Quasirandom Structures (SQS) for alloys or Normal Mode Sampling (NMS) for molecules.

Complementing this is the "Two-Tier Configuration" system. This feature is designed to drastically lower the barrier to entry for users, making the powerful capabilities of the pipeline accessible to a wider audience. Instead of requiring a complex, verbose configuration file with dozens of DFT and MLIP parameters that demand expert knowledge, the user will only need to provide a minimal `input.yaml` file containing only the most essential information (e.g., chemical elements and composition). A new `ConfigExpander` heuristic engine will then process this minimal file, applying a built-in knowledge base of physics-based rules and best-practice defaults to generate a complete, fully-specified `exec_config_dump.yaml`. This fully specified file, which is human-readable and can be inspected for transparency, will then be used to drive the rest of the pipeline, ensuring both reproducibility and ease of use. Upon completion of this cycle, the MLIP-AutoPipe will be able to initiate its entire complex workflow from just a simple, human-friendly input file, representing a significant step towards a fully autonomous system.

## 2. System Architecture

The architecture for Cycle 02 builds directly upon the foundation laid in Cycle 01. It introduces the `ConfigExpander` at the very beginning of the workflow and integrates the new `StructureGenerator` module to intelligently populate the database, effectively automating the entire setup phase of the pipeline. The data flow is modified to prepend these two new components to the existing core engine.

1.  **User Input (`input.yaml`):** The workflow now officially begins with a minimal YAML file provided by the user. For this cycle, its specification will be formalised. It will contain a single top-level `system` block, which in turn contains keys for `elements` (a list of chemical symbols) and `composition` (a string formula or a dictionary of proportions). This file is the sole piece of required user input to start the entire process.
2.  **`ConfigExpander` (Heuristic Engine):** This new component is the first to be invoked by the main orchestrator. It acts as the "computational expert" that sets up the detailed parameters for the run.
    *   It reads and parses the `input.yaml` file, validating it against a Pydantic model to ensure correctness.
    *   It performs a material analysis by calling a classification function that uses the elemental information to automatically determine the material's bond type (Alloy, Molecule, Ionic, Covalent). This classification is the primary driver for many subsequent heuristic decisions.
    *   Based on this classification and other heuristics, it applies a set of rules to infer and populate all other required parameters. This includes selecting default DFT settings (pseudopotentials, cutoffs) from the SSSP protocol, choosing an appropriate MLIP model type (e.g., ACE), and setting default simulation parameters for later cycles.
    *   Finally, it writes the complete, verbose configuration to a new file, `exec_config_dump.yaml`. This file serves as both a transparent record of the exact settings used for the run and the definitive set of instructions for the remainder of the workflow.
3.  **Orchestrator:** The main orchestrator script's responsibilities are expanded. It is now responsible for first invoking the `ConfigExpander` and then using the generated `exec_config_dump.yaml` to configure and run all subsequent modules. This ensures that every part of the pipeline operates with a consistent and complete set of parameters.
4.  **Module A: `StructureGenerator`:** This new module is invoked by the orchestrator immediately after the configuration expansion. Its purpose is to create the initial raw material for the MLIP.
    *   It reads the system information from the full configuration file, paying special attention to the `structure_type` key determined by the `ConfigExpander`.
    *   Based on this bond type, it calls the appropriate internal generation method (e.g., `_generate_sqs`, `_generate_nms`). Each of these methods will be responsible for creating a list of `ase.Atoms` objects.
    *   After generating the structures, it connects to the `AseDB` (using the database path specified in the configuration) and populates it with these new structures, giving them the default state "unlabelled". This signals to the next module in the pipeline that these structures are ready for processing.
5.  **Downstream Modules (Unchanged):** The `LabellingEngine` and `TrainingEngine` from Cycle 01 remain architecturally unchanged. Their implementation is already modular enough to handle the new upstream components. The `LabellingEngine` will now find the diverse set of structures created by the `StructureGenerator` in the database (instead of manually inserted ones) and will proceed with the DFT calculations as before, now configured entirely by the `exec_config_dump.yaml`.

This architecture effectively prepends the new intelligent setup phase to the core computational engine developed in Cycle 01. This moves the system from a proof-of-concept to a genuinely automated tool, significantly enhancing its usability and power.

## 3. Design Architecture

The design for this cycle introduces new classes for configuration management and the structure generation module, adhering to the principles of separation of concerns and dependency injection for testability.

-   **`src/mlip_autopipec/config/expander.py`:**
    -   **`ConfigExpander` class:** This class will encapsulate all the heuristic logic for setting up the calculation.
        -   `__init__(self, input_config: dict)`: Initialises with the parsed content of the user's `input.yaml`.
        -   `expand() -> dict`: The main public method. It orchestrates the sequence of private method calls to perform the expansion and returns the full configuration dictionary.
        -   `_determine_bond_type(self) -> str`: A private method that uses libraries like `pymatgen` to analyse the electronegativity differences and atomic properties of the elements in the system to return a string ('alloy', 'molecule', etc.). This is a critical decision point in the heuristic engine.
        -   `_populate_dft_params(self)`: Populates the `dft_compute` section of the config, referencing an internal data structure representing the SSSP protocol to choose appropriate pseudopotentials and cutoffs.
        -   `_populate_mlip_params(self)`: Populates the `mlip_training` section with sensible defaults for the ACE model.
-   **`src/mlip_autopipec/config/models.py`:**
    -   **Pydantic Models:** `InputConfig` and `FullConfig` will be defined here using Pydantic. This is a crucial step for robustness. These models serve as the schema for the configuration files. Pydantic will automatically validate the structure of the `input.yaml` provided by the user, ensuring type safety and providing clear, informative error messages for any invalid inputs, such as mis-spelled keys or incorrect data types.
-   **`src/mlip_autopipec/modules/structure_generator.py`:**
    -   **`StructureGenerator` class:** This class will contain the scientific logic for creating atomic structures.
        -   `__init__(self, db: AseDB, config: dict)`: Takes the database wrapper and the *full*, expanded configuration dictionary as dependencies.
        -   `run()`: The main public method. It reads the `structure_type` from the config and calls the appropriate private generation method, acting as a dispatcher.
        -   `_generate_sqs(self) -> list[ase.Atoms]`: Implements the logic for generating Special Quasirandom Structures. For robustness, this will likely involve wrapping a well-tested external tool or library like `icet`, and the method will handle the creation of input for and parsing of output from this tool. It will also include logic for systematically applying various volumetric and shear strains to the generated SQS supercells.
        -   `_generate_nms(self) -> list[ase.Atoms]`: Implements Normal Mode Sampling for molecular structures. This will involve an initial structure optimisation using an ASE optimiser with a low-cost calculator, a Hessian calculation, and then displacing the atoms along the calculated normal mode vectors to generate a set of distorted structures.
        -   (Future placeholders) The class design will include placeholders for `_generate_airss` and `_generate_rattle` methods. While they may not be fully implemented in this cycle, their inclusion in the design makes the class easier to extend in the future.
-   **`src/mlip_autopipec/main.py` (CLI Entry Point):**
    -   The main CLI function, to be fully developed in Cycle 05, will be updated to reflect the new workflow. It will now take the path to `input.yaml` as its primary argument.
    -   The first step within the CLI's logic will be to read the `input.yaml`, validate it using the `InputConfig` Pydantic model, and then instantiate and run the `ConfigExpander`.
    -   The resulting full configuration will be saved to `exec_config_dump.yaml` for user inspection and also passed in memory to the main orchestrator to drive the rest of the run.

This design cleanly separates the heuristic configuration logic from the scientific logic of structure generation, making both components easier to maintain, test, and extend independently.

## 4. Implementation Approach

The implementation will be staged to build the new functionalities on a solid base, with a strong emphasis on testing at each stage.

1.  **Configuration Models:** The first and most critical step is to define the Pydantic models for `InputConfig` and `FullConfig`. This step codifies the data structures that the entire system will use. It serves as a precise form of documentation and provides immediate benefits through automated validation. Unit tests will be written to ensure the models correctly accept valid data and raise `ValidationError` for malformed `input.yaml` files.
2.  **`ConfigExpander` Implementation:**
    *   Development of the `ConfigExpander` will begin with the `_determine_bond_type` method, as this is the core of the heuristic logic. This function will be thoroughly unit-tested to ensure it correctly classifies a wide range of chemical formulas.
    *   Next, the methods for populating the DFT and MLIP parameters with sensible, fixed defaults will be implemented. The logic to dynamically select parameters (e.g., based on SSSP data) will be built and tested in isolation.
    *   Finally, the main `expand()` method will be implemented, tying the other private methods together into a coherent sequence.
3.  **CLI Integration:** The main orchestrator/CLI script will be updated to accept `input.yaml` as its primary argument. The logic to call the `ConfigExpander`, save the full configuration dump to disk, and then use this dictionary to configure the downstream modules will be added. At this point, the entire pipeline can be run with the new configuration system, though it would still require manually added structures in the database until the `StructureGenerator` is complete.
4.  **`StructureGenerator` - SQS:** The SQS generation method will be implemented first, as it is a common and important use case for alloy materials. This will involve writing a robust wrapper around an existing command-line tool or library, handling input generation, process execution, and output parsing. The output must be a list of `ase.Atoms` objects.
5.  **`StructureGenerator` - NMS:** The Normal Mode Sampling method for molecules will be implemented next. This will likely require using a library that can perform a Hessian calculation (e.g., via an ASE calculator interface) and then applying the displacements, which will require careful numerical implementation.
6.  **`StructureGenerator` - Main `run()` Method:** The main `run()` method of the `StructureGenerator` will be implemented. This method will act as a dispatcher, checking the configuration and calling the correct private generation method based on the `structure_type`. It will also contain the logic to save the list of generated structures to the database via the `AseDB` wrapper.
7.  **Full Workflow Integration:** Finally, the fully implemented `StructureGenerator` will be integrated into the main orchestrator script. The new, complete workflow for this cycle will be: `ConfigExpander` -> `StructureGenerator` -> `LabellingEngine` -> `TrainingEngine`. The system will be tested end-to-end (with mocks for DFT) to ensure the new components are correctly chained.

## 5. Test Strategy

Testing for Cycle 02 is vital to ensure the correctness of the new automated setup phase. The strategy will focus on the heuristic logic of the `ConfigExpander` and the physical and structural correctness of the output from the new generation algorithms.

**Unit Testing Approach (Min 300 words):**
-   **`ConfigExpander`:** This class is highly suitable for unit testing as it is essentially a pure function that transforms a small dictionary into a large one. Each heuristic rule will be individually tested. For example, a test will provide `{'elements': ['Fe', 'Pt']}` as input and assert that the `_determine_bond_type` method returns the string `'alloy'`. Another test will check that for a given set of elements, the `_populate_dft_params` method selects the correct pseudopotential names and cutoff energies by mocking the internal SSSP data source. The main `expand` method will be tested to ensure the final dictionary has the correct, complete structure and contains all the required keys for the downstream modules to function.
-   **Pydantic Models:** The Pydantic models themselves will be tested. This involves writing tests that attempt to instantiate the models with malformed data (e.g., missing required keys, keys with the wrong data types, mis-spelled keys) and asserting that a `ValidationError` is raised. This ensures the validation layer is working correctly.
-   **`StructureGenerator`:** Each generation method (`_generate_sqs`, `_generate_nms`) within the `StructureGenerator` will be unit-tested. As these may rely on external libraries or command-line tools, the underlying calls to those tools will be mocked to ensure the tests are fast and isolated. The tests will focus on verifying that the generator class correctly parses the configuration, calls the backend tool with the right parameters (e.g., correct composition, supercell size), and correctly transforms the tool's output into a list of `ase.Atoms` objects. For example, the SQS test will verify that the generated structures have the correct chemical composition and that the number of generated structures matches what was requested in the configuration.

**Integration Testing Approach (Min 300 words):**
-   **Config -> Generator -> DB:** A key integration test will verify the initial part of the new workflow, ensuring the three new components work together seamlessly. It will start with a minimal `input.yaml` file on the filesystem. The test will invoke the `ConfigExpander` and then pass the resulting full configuration dictionary to an instance of the `StructureGenerator`. The `StructureGenerator` will then be run. Finally, the test will connect to a real (but temporary) `AseDB` to verify that the correct number of structures, with the correct metadata and chemical composition, have been successfully added to the database with the state "unlabelled". This single test validates that the configuration data is correctly interpreted by the generator and that the generated structures are persisted correctly for the next stage of the pipeline.
-   **Full Workflow Smoke Test:** An end-to-end "smoke test" for the newly extended workflow will be created. It will start with a simple `input.yaml` for a system like elemental Si. It will then run the entire, updated pipeline: `ConfigExpander` -> `StructureGenerator` -> `LabellingEngine` -> `TrainingEngine`. To ensure the test is fast, the DFT and MLIP training calls will be mocked to return canned results immediately. The purpose of this test is not to check for numerical accuracy but to ensure that the data and configuration flow correctly through all four modules without crashing or raising exceptions. This test is crucial for verifying that the integration of the new modules has not introduced any regressions or broken the core workflow from Cycle 01.