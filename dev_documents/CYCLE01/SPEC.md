# CYCLE 01: SPEC.md

## 1. Summary

This document provides the detailed technical specifications for Cycle 01 of the Autonomous Development Environment (AC-CDD) project. The primary objective of this cycle is to establish the foundational command-line interface (CLI) and the project initialisation process. This initial phase is critical as it sets up the core structure of the application, including the configuration management system and the user-facing entry point. The key deliverable for this cycle is a functional `init` command that guides the user through the process of setting up their environment, ensuring that all necessary configuration files and API keys are in place.

The scope of this cycle is strictly limited to the creation of the CLI and the initialisation workflow. It does not include any of the more advanced features, such as the AI agents or the sandboxed execution environment, which will be developed in subsequent cycles. The successful completion of Cycle 01 will result in a stable and user-friendly command-line tool that can be used to configure a new AC-CDD project. This will provide a solid foundation upon which the more complex features of the system can be built. The focus is on creating a robust and intuitive user experience for the initial setup process, as this is the first interaction that a new user will have with the system.

The implementation will leverage modern, industry-standard Python libraries, such as Typer for the CLI and Pydantic for configuration management. This will ensure that the resulting code is clean, maintainable, and easy to extend in future cycles. The development process will be guided by a comprehensive test strategy, including both unit and integration tests, to ensure the reliability and correctness of the implemented features. By the end of this cycle, we will have a fully functional `init` command that can generate the `.env` and `ac_cdd_config.py` files, providing a seamless and straightforward onboarding experience for new users.

## 2. System Architecture

The system architecture for Cycle 01 is focused on the components required to deliver the core CLI and project initialisation functionality. It is a lean and modular architecture, designed to be easily extensible in subsequent cycles.

The main components of the architecture for this cycle are:

*   **Command-Line Interface (CLI):** The user-facing component of the system, responsible for parsing commands and arguments. It will be built using the Typer library, which provides a simple and elegant way to create modern, user-friendly command-line applications. The CLI will be the primary entry point for all user interactions with the AC-CDD system.

*   **Configuration Management System:** This component is responsible for managing the application's configuration. It will load settings from a `.env` file for sensitive information, such as API keys, and from an `ac_cdd_config.py` file for non-sensitive, user-configurable parameters. The Pydantic library will be used to define the structure of the configuration and to perform validation, ensuring that all required settings are present and have the correct types.

*   **Initialisation Service:** This service will encapsulate the logic for the `init` command. It will be responsible for prompting the user for the necessary API keys, generating the `.env` file from a template, and creating the default `ac_cdd_config.py` file. This service-oriented approach ensures a clean separation of concerns, with the CLI acting as a thin layer that delegates the actual business logic to the appropriate service.

The interaction between these components is straightforward. The user executes the `init` command via the CLI. The CLI then invokes the Initialisation Service, which carries out the steps required to set up the project's configuration. The Configuration Management System is used by the application to access the configuration values once they have been set up. This simple, layered architecture provides a solid foundation for the more complex features that will be added in later cycles.

## 3. Design Architecture

The design architecture for Cycle 01 is focused on creating a clean, maintainable, and testable codebase for the core CLI and initialisation functionality.

**File Structure:**

The relevant files for this cycle will be located within the `dev_src/ac_cdd_core/` directory:

*   `cli.py`: The main entry point for the Typer-based CLI.
*   `config.py`: Contains the Pydantic models for the application's configuration and the logic for loading settings from the `.env` and `ac_cdd_config.py` files.
*   `services/initialisation.py`: Implements the `InitialisationService` class, which contains the business logic for the `init` command.
*   `templates/`: A new directory that will store the templates for the files generated by the `init` command, such as `.env.template`.

**Class and Function Definitions:**

*   **`cli.py`:**
    *   `app = typer.Typer()`: The main Typer application instance.
    *   `@app.command() def init():`: The function that defines the `init` command. This function will be responsible for creating an instance of the `InitialisationService` and calling its `run` method.

*   **`config.py`:**
    *   `class Settings(BaseSettings):`: A Pydantic model that defines the structure of the application's configuration. It will include fields for all the required API keys and other configurable parameters.
    *   `def load_settings():`: A function that loads the configuration from the `.env` and `ac_cdd_config.py` files and returns an instance of the `Settings` model.

*   **`services/initialisation.py`:**
    *   `class InitialisationService:`: A class that encapsulates the logic for the `init` command.
        *   `def run(self):`: The main method of the service. It will orchestrate the process of checking for existing configuration files, prompting the user for input, and generating the new configuration files.
        *   `_prompt_for_api_keys(self):`: A private method that handles the interactive prompts for the API keys.
        *   `_generate_env_file(self):`: A private method that creates the `.env` file from a template.
        *   `_generate_config_file(self):`: A private method that creates the default `ac_cdd_config.py` file.

This design ensures a clear separation of concerns, with the CLI responsible for command-line interaction, the service responsible for business logic, and the config module responsible for configuration management. This makes the code easier to understand, test, and maintain.

## 4. Implementation Approach

The implementation of Cycle 01 will be carried out in a series of logical, sequential steps, ensuring that each part of the functionality is built and tested before moving on to the next.

1.  **Set up `pyproject.toml`:** The first step is to configure the `pyproject.toml` file to define the CLI entry point. This will allow the application to be run as a command-line tool using a command like `uv run manage.py`.

2.  **Implement the CLI entry point:** The `cli.py` file will be created with a basic Typer application. This will include the main `app` instance and a placeholder for the `init` command.

3.  **Create the configuration models:** The `config.py` file will be created with the Pydantic `Settings` model. This model will define all the configuration parameters required by the application, including the API keys.

4.  **Implement the Initialisation Service:** The `InitialisationService` class will be created in `services/initialisation.py`. The initial implementation will focus on the core logic of the `run` method, which will orchestrate the initialisation process.

5.  **Implement the user prompts:** The `_prompt_for_api_keys` method will be implemented to provide an interactive way for the user to enter their API keys. This will use Typer's `prompt` function to ensure a good user experience.

6.  **Create the file templates:** The templates for the `.env` and `ac_cdd_config.py` files will be created in the `dev_src/ac_cdd_core/templates/` directory.

7.  **Implement the file generation logic:** The `_generate_env_file` and `_generate_config_file` methods will be implemented to read the templates, substitute the user-provided values, and write the new configuration files to the project's root directory.

8.  **Integrate the service with the CLI:** The `init` command in `cli.py` will be updated to create an instance of the `InitialisationService` and call its `run` method.

9.  **Write unit tests:** Unit tests will be written for the `InitialisationService` and the configuration management system. These tests will use mocks to isolate the code from the filesystem and user input.

10. **Write integration tests:** Integration tests will be written for the `init` command using Typer's `CliRunner`. These tests will verify the end-to-end functionality of the command, ensuring that it correctly generates the configuration files based on simulated user input.

By following this step-by-step approach, we can ensure that the implementation is carried out in a structured and methodical manner, resulting in a high-quality, well-tested codebase.

## 5. Test Strategy

The test strategy for Cycle 01 is designed to ensure the correctness and reliability of the core CLI and project initialisation functionality. It combines unit testing to verify the individual components in isolation and integration testing to validate the end-to-end workflow.

**Unit Testing Approach:**

The focus of the unit tests will be on the business logic encapsulated within the `InitialisationService` and the `config.py` module. The `pytest` framework will be used, along with the `unittest.mock` library, to isolate the code under test from external dependencies.

*   **`InitialisationService`:** The unit tests for this service will verify the logic for prompting the user, generating files, and handling existing configurations. The filesystem and user input will be mocked to allow the tests to be run in a controlled and predictable environment. We will test the following scenarios:
    *   The service correctly prompts for all required API keys.
    *   The service correctly generates the `.env` and `ac_cdd_config.py` files with the correct content.
    *   The service correctly detects existing configuration files and prompts the user for confirmation before overwriting them.

*   **`config.py`:** The unit tests for the configuration management system will verify that the settings are correctly loaded from the `.env` and `ac_cdd_config.py` files. We will use mock files to simulate different configuration scenarios and ensure that the `Settings` model is correctly populated.

**Integration Testing Approach:**

Integration testing will focus on the end-to-end functionality of the `init` command. We will use the `CliRunner` utility provided by Typer to programmatically invoke the CLI and assert on its output and the side effects it produces (i.e., the creation of files).

The integration tests will cover the following scenarios:

*   **Happy Path:** Running the `init` command in a clean project directory. The test will provide simulated user input for the API key prompts and then verify that the `.env` and `ac_cdd_config.py` files are created with the expected content.

*   **Existing Configuration:** Running the `init` command in a project where the configuration files already exist. The test will simulate the user confirming that they want to overwrite the existing files and then verify that the new files are created correctly.

*   **User Cancellation:** Running the `init` command and simulating the user declining to overwrite the existing configuration files. The test will verify that no changes are made to the filesystem.

By combining these unit and integration testing approaches, we can achieve a high level of confidence in the quality and reliability of the Cycle 01 deliverables.
